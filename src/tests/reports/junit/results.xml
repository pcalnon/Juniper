<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="12" skipped="3" tests="155" time="268.346" timestamp="2026-01-15T20:42:45.796700-06:00" hostname="yamaguchi"><testcase classname="integration.test_comprehensive_serialization.TestDeterministicTrainingResume" name="test_deterministic_training_resume" time="10.255"><failure message="AssertionError: &#10;Arrays are not almost equal to 5 decimals&#10;Resumed training diverged from continuous training&#10;Mismatched elements: 10 / 10 (100%)&#10;First 5 mismatches are at indices:&#10; [0, 0]: -0.06055125594139099 (ACTUAL), -0.09020629525184631 (DESIRED)&#10; [1, 0]: 0.17347075045108795 (ACTUAL), 0.14152517914772034 (DESIRED)&#10; [2, 0]: 0.6829667091369629 (ACTUAL), 0.6615568399429321 (DESIRED)&#10; [3, 0]: -0.4994625747203827 (ACTUAL), -0.5184578895568848 (DESIRED)&#10; [4, 0]: 0.5226701498031616 (ACTUAL), 0.5043010711669922 (DESIRED)&#10;Max absolute difference among violations: 0.03194557&#10;Max relative difference among violations: 0.5111792&#10; ACTUAL: array([[-0.06055],&#10;       [ 0.17347],&#10;       [ 0.68297],...&#10; DESIRED: array([[-0.09021],&#10;       [ 0.14153],&#10;       [ 0.66156],...">self = &lt;test_comprehensive_serialization.TestDeterministicTrainingResume testMethod=test_deterministic_training_resume&gt;

    def test_deterministic_training_resume(self):
        """
        Critical test: Train → Save → Load → Resume should be identical to continuous training.
        This is the most important test for deterministic reproducibility.
        """
        # Setup
        config = CascadeCorrelationConfig(
            input_size=2,
            output_size=1,
            candidate_pool_size=3,
            candidate_epochs=10,
            output_epochs=20,
            max_hidden_units=2,
            random_seed=42,
        )
    
        # Create test data
        torch.manual_seed(42)
        x_train = torch.randn(50, 2)
        y_train = (x_train[:, 0] &gt; x_train[:, 1]).float().unsqueeze(1)
    
        # Scenario A: Train for 20 epochs, save, train for 20 more
        network_a = CascadeCorrelationNetwork(config=config)
        network_a.fit(
            x_train=x_train,
            y_train=y_train,
            max_epochs=20
        )
        serializer = CascadeHDF5Serializer()
        with tempfile.NamedTemporaryFile(suffix=".h5", delete=False) as f:
            temp_file = f.name
        try:
            success = serializer.save_network(network_a, temp_file)
            self.assertTrue(success, "Failed to save network")
            network_a_resumed = serializer.load_network(temp_file)
            self.assertIsNotNone(network_a_resumed, "Failed to load network")
            network_a_resumed.fit(x_train, y_train, epochs=20)
    
            # Scenario B: Train continuously for 40 epochs
            network_b = CascadeCorrelationNetwork(config=config)
            network_b.fit(x_train, y_train, epochs=40)
    
            # Verify outputs are identical
            torch.manual_seed(999)  # Different seed for test data
            test_x = torch.randn(10, 2)
            output_a = network_a_resumed.forward(test_x)
            output_b = network_b.forward(test_x)
&gt;           np.testing.assert_array_almost_equal(
                output_a.detach().numpy(),
                output_b.detach().numpy(),
                decimal=5,
                err_msg="Resumed training diverged from continuous training",
            )
E           AssertionError: 
E           Arrays are not almost equal to 5 decimals
E           Resumed training diverged from continuous training
E           Mismatched elements: 10 / 10 (100%)
E           First 5 mismatches are at indices:
E            [0, 0]: -0.06055125594139099 (ACTUAL), -0.09020629525184631 (DESIRED)
E            [1, 0]: 0.17347075045108795 (ACTUAL), 0.14152517914772034 (DESIRED)
E            [2, 0]: 0.6829667091369629 (ACTUAL), 0.6615568399429321 (DESIRED)
E            [3, 0]: -0.4994625747203827 (ACTUAL), -0.5184578895568848 (DESIRED)
E            [4, 0]: 0.5226701498031616 (ACTUAL), 0.5043010711669922 (DESIRED)
E           Max absolute difference among violations: 0.03194557
E           Max relative difference among violations: 0.5111792
E            ACTUAL: array([[-0.06055],
E                  [ 0.17347],
E                  [ 0.68297],...
E            DESIRED: array([[-0.09021],
E                  [ 0.14153],
E                  [ 0.66156],...

src/tests/integration/test_comprehensive_serialization.py:79: AssertionError</failure></testcase><testcase classname="integration.test_comprehensive_serialization.TestHiddenUnitsPreservation" name="test_hidden_units_preservation" time="1.687" /><testcase classname="integration.test_comprehensive_serialization.TestConfigRoundtrip" name="test_config_roundtrip" time="1.538" /><testcase classname="integration.test_comprehensive_serialization.TestActivationFunctionRestoration" name="test_activation_function_restoration" time="4.700" /><testcase classname="integration.test_comprehensive_serialization.TestTorchRandomStateRestoration" name="test_torch_random_state_restoration" time="2.401" /><testcase classname="integration.test_comprehensive_serialization.TestHistoryPreservation" name="test_history_preservation" time="1.563" /><testcase classname="integration.test_serialization.TestUUIDPersistence" name="test_uuid_preserved_after_load" time="1.645" /><testcase classname="integration.test_serialization.TestUUIDPersistence" name="test_multiple_save_load_cycles_preserve_uuid" time="3.253" /><testcase classname="integration.test_serialization.TestRandomSeedPreservation" name="test_random_seed_parameters_preserved" time="1.603" /><testcase classname="integration.test_serialization.TestRandomSeedPreservation" name="test_deterministic_forward_pass" time="1.652" /><testcase classname="integration.test_serialization.TestRandomSeedPreservation" name="test_random_state_data_in_file" time="0.828" /><testcase classname="integration.test_serialization.TestHistoryPreservation" name="test_history_keys_preserved" time="1.716" /><testcase classname="integration.test_serialization.TestHistoryPreservation" name="test_hidden_units_history_preserved" time="1.842" /><testcase classname="integration.test_serialization.TestConfigRoundtrip" name="test_config_serialization_excludes_non_serializable" time="2.191" /><testcase classname="integration.test_serialization.TestConfigRoundtrip" name="test_config_values_preserved" time="2.048" /><testcase classname="integration.test_serialization.TestActivationFunctionRestoration" name="test_activation_function_name_restored" time="2.314" /><testcase classname="integration.test_serialization.TestActivationFunctionRestoration" name="test_activation_function_callable_restored" time="2.317" /><testcase classname="integration.test_serialization.TestHiddenUnitsPreservation" name="test_hidden_units_count_preserved" time="1.817" /><testcase classname="integration.test_serialization.TestHiddenUnitsPreservation" name="test_hidden_units_weights_preserved" time="2.157" /><testcase classname="integration.test_serialization.TestHiddenUnitsPreservation" name="test_hidden_units_checksums_verified" time="2.173" /><testcase classname="integration.test_serialization.TestShapeValidation" name="test_output_weights_shape_validated" time="1.826" /><testcase classname="integration.test_serialization.TestShapeValidation" name="test_hidden_units_shape_validated" time="1.766" /><testcase classname="integration.test_serialization.TestFormatValidation" name="test_valid_format_accepted" time="1.659" /><testcase classname="integration.test_serialization.TestFormatValidation" name="test_format_verification_info" time="0.846" /><testcase classname="integration.test_serialization.TestRandomStateRestoration" name="test_python_random_state_restoration" time="2.750" /><testcase classname="integration.test_serialization.TestRandomStateRestoration" name="test_numpy_random_state_restoration" time="2.602" /><testcase classname="integration.test_serialization.TestRandomStateRestoration" name="test_torch_random_state_restoration" time="2.598" /><testcase classname="integration.test_serialization.TestRandomStateRestoration" name="test_deterministic_training_resume" time="3.032" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemBasic" name="test_2_spiral_learning" time="3.039"><failure message="AssertionError: Network did not learn: initial_loss=0.243668, final_loss=0.243668: improvement=0.000000 &lt; min_improvement=0.01">self = &lt;test_spiral_problem.TestSpiralProblemBasic object at 0x795a767e2e90&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a772152b0&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    def test_2_spiral_learning(self, spiral_network):
        """Test that network can learn 2-spiral problem."""
        set_deterministic_behavior(42)
    
        # Generate 2-spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=50,
            noise=0.05,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history, elapsed_time = measure_training_time(
            spiral_network, x, y, max_epochs=10, early_stopping=False
        )
        final_accuracy = spiral_network.calculate_accuracy(x, y)
        # Verify learning occurred
&gt;       assert_network_learns(
            initial_loss=history['train_loss'][0],
            final_loss=history['train_loss'][-1],
            min_improvement=0.01
        )

src/tests/integration/test_spiral_problem.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

initial_loss = 0.2436680942773819, final_loss = 0.2436680942773819, min_improvement = 0.01, msg = 'Network did not learn: initial_loss=0.243668, final_loss=0.243668'

    def assert_network_learns(
        initial_loss: float,
        final_loss: float,
        min_improvement: float = 0.01,
        msg: Optional[str] = None
    ) -&gt; None:
        """
        Assert that network shows learning (loss improvement).
    
        Args:
            initial_loss: Loss at start of training
            final_loss: Loss at end of training
            min_improvement: Minimum relative improvement required
            msg: Optional error message
        """
        if msg is None:
            msg = f"Network did not learn: initial_loss={initial_loss:.6f}, final_loss={final_loss:.6f}"
    
        improvement = (initial_loss - final_loss) / initial_loss
&gt;       assert improvement &gt;= min_improvement, f"{msg}: improvement={improvement:.6f} &lt; min_improvement={min_improvement}" # trunk-ignore(bandit/B101)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: Network did not learn: initial_loss=0.243668, final_loss=0.243668: improvement=0.000000 &lt; min_improvement=0.01

src/tests/helpers/assertions.py:340: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemBasic" name="test_3_spiral_learning" time="3.137"><failure message="assert 0.35 &gt; 0.35">self = &lt;test_spiral_problem.TestSpiralProblemBasic object at 0x795a767e3110&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b4980&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    def test_3_spiral_learning(self, spiral_network):
        """Test that network can learn 3-spiral problem."""
        set_deterministic_behavior(42)
    
        # Generate 3-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=3,
            n_per_spiral=40,
            noise=0.03,
            seed=42
        )
    
        # Adjust network for 3-class problem
        spiral_network.output_size = 3
        spiral_network.output_weights = torch.randn(
            spiral_network.input_size, 3, requires_grad=True
        ) * spiral_network.random_value_scale
        spiral_network.output_bias = torch.randn(3, requires_grad=True) * spiral_network.random_value_scale
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=8)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Verify learning
&gt;       assert final_accuracy &gt; initial_accuracy  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.35 &gt; 0.35

src/tests/integration/test_spiral_problem.py:100: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemProgressive" name="test_n_spiral_difficulty_progression[2]" time="2.949"><failure message="assert 0.5 &gt;= 0.5166666666666667">self = &lt;test_spiral_problem.TestSpiralProblemProgressive object at 0x795a767e34d0&gt;, n_spirals = 2

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    @pytest.mark.parametrize("n_spirals", [2, 3, 4])
    def test_n_spiral_difficulty_progression(self, n_spirals):
        """Test that network can handle increasing spiral complexity."""
        set_deterministic_behavior(42)
    
        # Create network configured for n-spiral problem
        from cascade_correlation.cascade_correlation import CascadeCorrelationNetwork
        network = CascadeCorrelationNetwork.create_simple_network(
            input_size=2,
            output_size=n_spirals,
            learning_rate=0.05,
            max_hidden_units=min(8, n_spirals * 2),
            candidate_pool_size=12,
            correlation_threshold=0.15
        )
    
        # Generate n-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=n_spirals,
            n_per_spiral=30,
            noise=0.02,
            seed=42
        )
    
        # Train network
        initial_accuracy = network.calculate_accuracy(x, y)
        history = network.fit(x, y, max_epochs=6)
        final_accuracy = network.calculate_accuracy(x, y)
    
        # Basic learning verification
&gt;       assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.5 &gt;= 0.5166666666666667

src/tests/integration/test_spiral_problem.py:147: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemProgressive" name="test_n_spiral_difficulty_progression[3]" time="2.796"><failure message="assert 0.37777777777777777 &gt; (0.3333333333333333 * 1.2)">self = &lt;test_spiral_problem.TestSpiralProblemProgressive object at 0x795a767e3610&gt;, n_spirals = 3

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    @pytest.mark.parametrize("n_spirals", [2, 3, 4])
    def test_n_spiral_difficulty_progression(self, n_spirals):
        """Test that network can handle increasing spiral complexity."""
        set_deterministic_behavior(42)
    
        # Create network configured for n-spiral problem
        from cascade_correlation.cascade_correlation import CascadeCorrelationNetwork
        network = CascadeCorrelationNetwork.create_simple_network(
            input_size=2,
            output_size=n_spirals,
            learning_rate=0.05,
            max_hidden_units=min(8, n_spirals * 2),
            candidate_pool_size=12,
            correlation_threshold=0.15
        )
    
        # Generate n-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=n_spirals,
            n_per_spiral=30,
            noise=0.02,
            seed=42
        )
    
        # Train network
        initial_accuracy = network.calculate_accuracy(x, y)
        history = network.fit(x, y, max_epochs=6)
        final_accuracy = network.calculate_accuracy(x, y)
    
        # Basic learning verification
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Expected accuracy should decrease with complexity but still be above random
        random_accuracy = 1.0 / n_spirals
        # At least 20% better than random
&gt;       assert final_accuracy &gt; random_accuracy * 1.2  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.37777777777777777 &gt; (0.3333333333333333 * 1.2)

src/tests/integration/test_spiral_problem.py:152: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemProgressive" name="test_n_spiral_difficulty_progression[4]" time="3.052"><failure message="assert 0.26666666666666666 &gt; (0.25 * 1.2)">self = &lt;test_spiral_problem.TestSpiralProblemProgressive object at 0x795a767fb230&gt;, n_spirals = 4

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    @pytest.mark.parametrize("n_spirals", [2, 3, 4])
    def test_n_spiral_difficulty_progression(self, n_spirals):
        """Test that network can handle increasing spiral complexity."""
        set_deterministic_behavior(42)
    
        # Create network configured for n-spiral problem
        from cascade_correlation.cascade_correlation import CascadeCorrelationNetwork
        network = CascadeCorrelationNetwork.create_simple_network(
            input_size=2,
            output_size=n_spirals,
            learning_rate=0.05,
            max_hidden_units=min(8, n_spirals * 2),
            candidate_pool_size=12,
            correlation_threshold=0.15
        )
    
        # Generate n-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=n_spirals,
            n_per_spiral=30,
            noise=0.02,
            seed=42
        )
    
        # Train network
        initial_accuracy = network.calculate_accuracy(x, y)
        history = network.fit(x, y, max_epochs=6)
        final_accuracy = network.calculate_accuracy(x, y)
    
        # Basic learning verification
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Expected accuracy should decrease with complexity but still be above random
        random_accuracy = 1.0 / n_spirals
        # At least 20% better than random
&gt;       assert final_accuracy &gt; random_accuracy * 1.2  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.26666666666666666 &gt; (0.25 * 1.2)

src/tests/integration/test_spiral_problem.py:152: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_noise_robustness[0.01]" time="3.036"><failure message="assert 0.525 &gt; 0.55">self = &lt;test_spiral_problem.TestSpiralProblemRobustness object at 0x795a767e3890&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b56a0&gt;, noise_level = 0.01

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.parametrize("noise_level", [0.01, 0.05, 0.1])
    def test_spiral_noise_robustness(self, spiral_network, noise_level):
        """Test network performance with different noise levels."""
        set_deterministic_behavior(42)
    
        # Generate noisy spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=40,
            noise=noise_level,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=6)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should learn even with noise, though performance may degrade
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Performance should still be better than random (0.5 for 2-class)
        if noise_level &lt;= 0.05:  # sourcery skip: no-conditionals-in-tests
            # Should handle small noise well
&gt;           assert final_accuracy &gt; 0.55  # trunk-ignore(bandit/B101)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           assert 0.525 &gt; 0.55

src/tests/integration/test_spiral_problem.py:188: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_noise_robustness[0.05]" time="3.094"><failure message="assert 0.55 &gt; 0.55">self = &lt;test_spiral_problem.TestSpiralProblemRobustness object at 0x795a767e39d0&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b5940&gt;, noise_level = 0.05

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.parametrize("noise_level", [0.01, 0.05, 0.1])
    def test_spiral_noise_robustness(self, spiral_network, noise_level):
        """Test network performance with different noise levels."""
        set_deterministic_behavior(42)
    
        # Generate noisy spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=40,
            noise=noise_level,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=6)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should learn even with noise, though performance may degrade
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Performance should still be better than random (0.5 for 2-class)
        if noise_level &lt;= 0.05:  # sourcery skip: no-conditionals-in-tests
            # Should handle small noise well
&gt;           assert final_accuracy &gt; 0.55  # trunk-ignore(bandit/B101)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           assert 0.55 &gt; 0.55

src/tests/integration/test_spiral_problem.py:188: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_noise_robustness[0.1]" time="3.307" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_data_size_scaling[20]" time="3.567"><failure message="assert 0.5 &gt; 0.525">self = &lt;test_spiral_problem.TestSpiralProblemRobustness object at 0x795a767fb490&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b5be0&gt;, n_per_spiral = 20

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.parametrize("n_per_spiral", [20, 50, 100])
    def test_spiral_data_size_scaling(self, spiral_network, n_per_spiral):
        """Test network performance with different dataset sizes."""
        set_deterministic_behavior(42)
    
        # Generate spiral data of different sizes
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=n_per_spiral,
            noise=0.03,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=5)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should learn regardless of data size
&gt;       assert final_accuracy &gt; initial_accuracy # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.5 &gt; 0.525

src/tests/integration/test_spiral_problem.py:216: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_data_size_scaling[50]" time="2.981" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_data_size_scaling[100]" time="3.302" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemVisualization" name="test_spiral_training_progression" time="3.273"><failure message="assert 0.5 &gt; 0.5">self = &lt;test_spiral_problem.TestSpiralProblemVisualization object at 0x795a767e3b10&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b5e80&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    def test_spiral_training_progression(self, spiral_network):
        """Test and analyze training progression on spiral problem."""
        set_deterministic_behavior(42)
    
        # Generate spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=60,
            noise=0.04,
            seed=42
        )
    
        # Split into train/validation
        n_train = int(0.8 * len(x))
        indices = torch.randperm(len(x))
        train_indices, val_indices = indices[:n_train], indices[n_train:]
    
        x_train, y_train = x[train_indices], y[train_indices]
        x_val, y_val = x[val_indices], y[val_indices]
    
        # Train with validation
        history = spiral_network.fit(
            x_train, y_train,
            x_val, y_val,
            max_epochs=8,
            early_stopping=True
        )
    
        # Analyze training progression
        assert len(history['train_loss']) &gt; 0 # trunk-ignore(bandit/B101)
        assert len(history['train_accuracy']) &gt; 0 # trunk-ignore(bandit/B101)
    
        if 'value_loss' in history and history['value_loss']:  # sourcery skip: no-conditionals-in-tests
            assert len(history['value_loss']) &gt; 0 # trunk-ignore(bandit/B101)
            assert len(history['value_accuracy']) &gt; 0 # trunk-ignore(bandit/B101)
    
            # Validation accuracy should be reasonable
            final_val_accuracy = history['value_accuracy'][-1]
&gt;           assert final_val_accuracy &gt; 0.5 # trunk-ignore(bandit/B101)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           assert 0.5 &gt; 0.5

src/tests/integration/test_spiral_problem.py:268: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemEdgeCases" name="test_minimal_spiral_data" time="3.071" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemEdgeCases" name="test_perfect_spiral_separation" time="3.140"><failure message="assert 0.5166666666666667 &gt; 0.5166666666666667">self = &lt;test_spiral_problem.TestSpiralProblemEdgeCases object at 0x795a767e3d90&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b5d30&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    def test_perfect_spiral_separation(self, spiral_network):
        """Test network with perfectly separated spiral data."""
        set_deterministic_behavior(42)
    
        # Generate data with no noise (perfect separation)
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=30,
            noise=0.0,  # No noise - perfect separation
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=8)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should achieve very high accuracy with perfect data
&gt;       assert final_accuracy &gt; initial_accuracy  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.5166666666666667 &gt; 0.5166666666666667

src/tests/integration/test_spiral_problem.py:332: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemComparison" name="test_spiral_configuration_comparison" time="14.211" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_perfect_accuracy" time="0.901" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_zero_accuracy" time="0.917" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_random_accuracy" time="0.848" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_accuracy_with_trained_network" time="4.898" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[1]" time="1.102" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[5]" time="1.089" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[10]" time="1.348" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[50]" time="1.123" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[100]" time="1.135" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[2]" time="1.109" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[3]" time="0.863" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[5]" time="0.822" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[10]" time="0.782" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_none_inputs" time="0.779" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_mismatched_batch_sizes" time="0.941" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_wrong_shapes" time="0.798" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_non_tensor_inputs" time="0.915" /><testcase classname="unit.test_accuracy.TestAccuracyArgmax" name="test_accuracy_argmax_behavior" time="0.887" /><testcase classname="unit.test_accuracy.TestAccuracyArgmax" name="test_accuracy_tie_breaking" time="0.786" /><testcase classname="unit.test_accuracy.TestAccuracyEdgeCases" name="test_accuracy_empty_batch" time="0.765" /><testcase classname="unit.test_accuracy.TestAccuracyEdgeCases" name="test_accuracy_single_sample" time="0.865" /><testcase classname="unit.test_accuracy.TestAccuracyEdgeCases" name="test_accuracy_extreme_predictions" time="0.964" /><testcase classname="unit.test_accuracy.TestAccuracyConsistency" name="test_accuracy_methods_consistency" time="0.974" /><testcase classname="unit.test_accuracy.TestAccuracyConsistency" name="test_accuracy_deterministic" time="1.017" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_multiclass_accuracy[3]" time="0.734" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_multiclass_accuracy[5]" time="0.826" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_multiclass_accuracy[10]" time="0.755" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_imbalanced_accuracy" time="0.939" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_inheritance[happy-path-candidate-training-manager]" time="0.004" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_inheritance[base-manager-direct]" time="0.003" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args0-register_kwargs0-None-register-method-happy-path]" time="0.003" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args1-register_kwargs1-None-register-method-with-callable]" time="0.004" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args2-register_kwargs2-TypeError-register-method-none-name]" time="0.004" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args3-register_kwargs3-TypeError-register-method-missing-args]" time="0.002" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[fork-None-start-method-fork]" time="0.003"><skipped type="pytest.skip" message="Skipping actual start() call for 'fork' to avoid multiprocessing complexity">/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/unit/test_candidate_training_manager.py:98: Skipping actual start() call for 'fork' to avoid multiprocessing complexity</skipped></testcase><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[spawn-None-start-method-spawn]" time="0.002"><skipped type="pytest.skip" message="Skipping actual start() call for 'spawn' to avoid multiprocessing complexity">/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/unit/test_candidate_training_manager.py:98: Skipping actual start() call for 'spawn' to avoid multiprocessing complexity</skipped></testcase><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[forkserver-None-start-method-forkserver]" time="0.003"><skipped type="pytest.skip" message="Skipping actual start() call for 'forkserver' to avoid multiprocessing complexity">/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/unit/test_candidate_training_manager.py:98: Skipping actual start() call for 'forkserver' to avoid multiprocessing complexity</skipped></testcase><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[invalid_method-ValueError-start-method-invalid]" time="0.006" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_repr_and_str" time="0.003" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_address_property" time="0.003" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_shutdown_without_start" time="0.003" /><testcase classname="unit.test_cascor_fix" name="test_sequential_candidate_training" time="15.763" /><testcase classname="unit.test_cascor_fix" name="test_individual_candidates" time="14.216" /><testcase classname="unit.test_critical_fixes" name="test_1_dataclass_fields" time="0.002" /><testcase classname="unit.test_critical_fixes" name="test_2_network_creation" time="0.713" /><testcase classname="unit.test_critical_fixes" name="test_3_candidate_training" time="6.199" /><testcase classname="unit.test_critical_fixes" name="test_4_get_single_candidate_data" time="0.665" /><testcase classname="unit.test_critical_fixes" name="test_5_training_results_dataclass" time="0.002" /><testcase classname="unit.test_final" name="test_candidate_units_simple" time="20.236" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_no_hidden_units" time="0.751" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_single_hidden_unit" time="0.794" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_multiple_hidden_units" time="0.742" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_deterministic" time="0.789" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[1]" time="0.778" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[5]" time="0.817" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[10]" time="0.772" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[50]" time="0.759" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[1]" time="0.662" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[2]" time="0.692" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[5]" time="0.665" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[10]" time="0.690" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[1]" time="0.693" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[2]" time="0.704" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[5]" time="0.702" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[10]" time="0.726" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_invalid_input_shape" time="0.846" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_1d_input" time="0.854" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_empty_input" time="0.768" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_nan_input" time="0.750"><failure message="cascade_correlation_exceptions.cascade_correlation_exceptions.ValidationError: Parameter 'x' contains NaN values">self = &lt;test_forward_pass.TestForwardPassValidation object at 0x795a766a1ba0&gt;, simple_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b6510&gt;

    @pytest.mark.unit
    def test_forward_pass_nan_input(self, simple_network):
        """Test forward pass with NaN input."""
        nan_input = torch.full((5, simple_network.input_size), float('nan'))
    
&gt;       output = simple_network.forward(nan_input)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/tests/unit/test_forward_pass.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b6510&gt;, x = tensor([[nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan]])

    def forward(self, x: torch.Tensor = None) -&gt; torch.Tensor:
        """
        Perform a forward pass through the network.
        Args:
            x: Input tensor (batch_size, input_features)
        Raises:
            ValidationError: If input tensor is invalid or has wrong shape
        Returns:
            Network output tensor (batch_size, output_features)
        """
        # Validate input (allow empty tensors for edge case handling)
&gt;       self._validate_tensor_input(x, "x", allow_empty=True)

src/cascade_correlation/cascade_correlation.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x795a6a8b6510&gt;, x = tensor([[nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan]]), param_name = 'x', allow_none = False, allow_empty = True

    def _validate_tensor_input( self, x: torch.Tensor, param_name: str = "x", allow_none: bool = False, allow_empty: bool = False) -&gt; None:
        """
        Validate tensor input parameters.
        Args:
            x: Input tensor to validate
            param_name: Name of the parameter for error messages
            allow_none: Whether to allow None values
            allow_empty: Whether to allow empty (zero-batch) tensors
        Raises:
            ValidationError: If tensor is invalid
        """
        if allow_none and x is None:
            return
        if x is None:
            raise ValidationError(f"Parameter '{param_name}' cannot be None")
        if not isinstance(x, torch.Tensor):
            raise ValidationError( f"Parameter '{param_name}' must be a torch.Tensor, got {type(x)}")
        if x.numel() == 0 and not allow_empty:
            raise ValidationError(f"Parameter '{param_name}' cannot be an empty tensor")
        # Skip NaN/Inf checks for empty tensors
        if x.numel() &gt; 0:
            if torch.isnan(x).any():
&gt;               raise ValidationError(f"Parameter '{param_name}' contains NaN values")
E               cascade_correlation_exceptions.cascade_correlation_exceptions.ValidationError: Parameter 'x' contains NaN values

src/cascade_correlation/cascade_correlation.py:727: ValidationError</failure></testcase><testcase classname="unit.test_forward_pass.TestForwardPassCascading" name="test_cascading_connections" time="0.757" /><testcase classname="unit.test_forward_pass.TestForwardPassCascading" name="test_hidden_unit_output_shapes" time="0.770" /><testcase classname="unit.test_forward_pass.TestForwardPassGradients" name="test_forward_pass_gradients_enabled" time="0.776" /><testcase classname="unit.test_forward_pass.TestForwardPassGradients" name="test_forward_pass_no_grad" time="0.831" /><testcase classname="unit.test_forward_pass.TestForwardPassActivationFunctions" name="test_forward_pass_different_activations[tanh]" time="0.780" /><testcase classname="unit.test_forward_pass.TestForwardPassActivationFunctions" name="test_forward_pass_different_activations[sigmoid]" time="0.800" /><testcase classname="unit.test_forward_pass.TestForwardPassActivationFunctions" name="test_forward_pass_different_activations[relu]" time="0.804" /><testcase classname="unit.test_forward_pass.TestForwardPassEdgeCases" name="test_forward_pass_single_sample" time="0.779" /><testcase classname="unit.test_forward_pass.TestForwardPassEdgeCases" name="test_forward_pass_large_batch" time="0.923" /><testcase classname="unit.test_forward_pass.TestForwardPassEdgeCases" name="test_forward_pass_extreme_weights" time="0.776" /><testcase classname="unit.test_hdf5" name="test_hdf5_serialization" time="0.002" /><testcase classname="unit.test_p1_fixes" name="test_1_early_stopping" time="3.921" /><testcase classname="unit.test_p1_fixes" name="test_2_optimizer_serialization" time="1.869" /><testcase classname="unit.test_p1_fixes" name="test_3_training_counters_persistence" time="1.800" /><testcase classname="unit.test_p1_fixes" name="test_4_queue_timeout" time="0.001" /><testcase classname="unit.test_p1_fixes" name="test_5_optimizer_initialization" time="0.687" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_perfect_prediction" time="0.752" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_computation" time="0.835" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_symmetric" time="0.772" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_no_grad" time="0.799" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[1]" time="0.754" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[5]" time="0.737" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[10]" time="0.814" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[50]" time="0.811" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[1]" time="0.811" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[2]" time="0.884" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[5]" time="0.687" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[10]" time="0.685" /><testcase classname="unit.test_residual_error.TestResidualErrorMagnitude" name="test_residual_error_magnitude_untrained" time="0.877" /><testcase classname="unit.test_residual_error.TestResidualErrorMagnitude" name="test_residual_error_zero_targets" time="0.818" /><testcase classname="unit.test_residual_error.TestResidualErrorMagnitude" name="test_residual_error_distribution" time="0.829" /><testcase classname="unit.test_residual_error.TestResidualErrorValidation" name="test_residual_error_mismatched_shapes" time="0.949" /><testcase classname="unit.test_residual_error.TestResidualErrorValidation" name="test_residual_error_wrong_target_size" time="1.163" /><testcase classname="unit.test_residual_error.TestResidualErrorValidation" name="test_residual_error_empty_input" time="1.089" /><testcase classname="unit.test_residual_error.TestResidualErrorNumericalStability" name="test_residual_error_extreme_values" time="0.938" /><testcase classname="unit.test_residual_error.TestResidualErrorNumericalStability" name="test_residual_error_inf_nan_handling" time="1.110" /><testcase classname="unit.test_residual_error.TestResidualErrorWithHiddenUnits" name="test_residual_error_with_hidden_units" time="1.086" /><testcase classname="unit.test_residual_error.TestResidualErrorWithHiddenUnits" name="test_residual_error_changes_with_training" time="0.993" /><testcase classname="unit.test_residual_error.TestResidualErrorCorrelation" name="test_residual_error_for_correlation" time="1.220" /><testcase classname="unit.test_residual_error.TestResidualErrorCorrelation" name="test_residual_error_mean_centering" time="1.034" /></testsuite></testsuites>