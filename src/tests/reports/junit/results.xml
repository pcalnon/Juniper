<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="2" failures="12" skipped="3" tests="134" time="12132.455" timestamp="2026-01-17T03:44:41.024508-06:00" hostname="yamaguchi"><testcase classname="" name="integration.test_serialization" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/integration/test_serialization.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/tests/integration/test_serialization.py:34: in &lt;module&gt;
    from cascade_correlation_config.cascade_correlation_config import (  # trunk-ignore(ruff/E402)
E   ModuleNotFoundError: No module named 'cascade_correlation_config'</error></testcase><testcase classname="" name="unit.test_hdf5" time="0.000"><error message="collection failure">ImportError while importing test module '/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/unit/test_hdf5.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
/opt/miniforge3/envs/JuniperCascor/lib/python3.14/importlib/__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/tests/unit/test_hdf5.py:10: in &lt;module&gt;
    from cascade_correlation_config.cascade_correlation_config import CascadeCorrelationConfig
E   ModuleNotFoundError: No module named 'cascade_correlation_config'</error></testcase><testcase classname="integration.test_comprehensive_serialization.TestDeterministicTrainingResume" name="test_deterministic_training_resume" time="186.927"><failure message="AssertionError: &#10;Arrays are not almost equal to 5 decimals&#10;Resumed training diverged from continuous training&#10;Mismatched elements: 10 / 10 (100%)&#10;First 5 mismatches are at indices:&#10; [0, 0]: -0.06055125594139099 (ACTUAL), -0.09020629525184631 (DESIRED)&#10; [1, 0]: 0.17347075045108795 (ACTUAL), 0.14152517914772034 (DESIRED)&#10; [2, 0]: 0.6829667091369629 (ACTUAL), 0.6615568399429321 (DESIRED)&#10; [3, 0]: -0.4994625747203827 (ACTUAL), -0.5184578895568848 (DESIRED)&#10; [4, 0]: 0.5226701498031616 (ACTUAL), 0.5043010711669922 (DESIRED)&#10;Max absolute difference among violations: 0.03194557&#10;Max relative difference among violations: 0.5111792&#10; ACTUAL: array([[-0.06055],&#10;       [ 0.17347],&#10;       [ 0.68297],...&#10; DESIRED: array([[-0.09021],&#10;       [ 0.14153],&#10;       [ 0.66156],...">self = &lt;test_comprehensive_serialization.TestDeterministicTrainingResume testMethod=test_deterministic_training_resume&gt;

    def test_deterministic_training_resume(self):
        """
        Critical test: Train → Save → Load → Resume should be identical to continuous training.
        This is the most important test for deterministic reproducibility.
        """
        # Setup
        config = CascadeCorrelationConfig(
            input_size=2,
            output_size=1,
            candidate_pool_size=3,
            candidate_epochs=10,
            output_epochs=20,
            max_hidden_units=2,
            random_seed=42,
        )
    
        # Create test data
        torch.manual_seed(42)
        x_train = torch.randn(50, 2)
        y_train = (x_train[:, 0] &gt; x_train[:, 1]).float().unsqueeze(1)
    
        # Scenario A: Train for 20 epochs, save, train for 20 more
        network_a = CascadeCorrelationNetwork(config=config)
        network_a.fit(
            x_train=x_train,
            y_train=y_train,
            max_epochs=20
        )
        serializer = CascadeHDF5Serializer()
        with tempfile.NamedTemporaryFile(suffix=".h5", delete=False) as f:
            temp_file = f.name
        try:
            success = serializer.save_network(network_a, temp_file)
            self.assertTrue(success, "Failed to save network")
            network_a_resumed = serializer.load_network(temp_file)
            self.assertIsNotNone(network_a_resumed, "Failed to load network")
            network_a_resumed.fit(x_train, y_train, epochs=20)
    
            # Scenario B: Train continuously for 40 epochs
            network_b = CascadeCorrelationNetwork(config=config)
            network_b.fit(x_train, y_train, epochs=40)
    
            # Verify outputs are identical
            torch.manual_seed(999)  # Different seed for test data
            test_x = torch.randn(10, 2)
            output_a = network_a_resumed.forward(test_x)
            output_b = network_b.forward(test_x)
&gt;           np.testing.assert_array_almost_equal(
                output_a.detach().numpy(),
                output_b.detach().numpy(),
                decimal=5,
                err_msg="Resumed training diverged from continuous training",
            )
E           AssertionError: 
E           Arrays are not almost equal to 5 decimals
E           Resumed training diverged from continuous training
E           Mismatched elements: 10 / 10 (100%)
E           First 5 mismatches are at indices:
E            [0, 0]: -0.06055125594139099 (ACTUAL), -0.09020629525184631 (DESIRED)
E            [1, 0]: 0.17347075045108795 (ACTUAL), 0.14152517914772034 (DESIRED)
E            [2, 0]: 0.6829667091369629 (ACTUAL), 0.6615568399429321 (DESIRED)
E            [3, 0]: -0.4994625747203827 (ACTUAL), -0.5184578895568848 (DESIRED)
E            [4, 0]: 0.5226701498031616 (ACTUAL), 0.5043010711669922 (DESIRED)
E           Max absolute difference among violations: 0.03194557
E           Max relative difference among violations: 0.5111792
E            ACTUAL: array([[-0.06055],
E                  [ 0.17347],
E                  [ 0.68297],...
E            DESIRED: array([[-0.09021],
E                  [ 0.14153],
E                  [ 0.66156],...

src/tests/integration/test_comprehensive_serialization.py:79: AssertionError</failure></testcase><testcase classname="integration.test_comprehensive_serialization.TestHiddenUnitsPreservation" name="test_hidden_units_preservation" time="1.880" /><testcase classname="integration.test_comprehensive_serialization.TestConfigRoundtrip" name="test_config_roundtrip" time="1.762" /><testcase classname="integration.test_comprehensive_serialization.TestActivationFunctionRestoration" name="test_activation_function_restoration" time="5.541" /><testcase classname="integration.test_comprehensive_serialization.TestTorchRandomStateRestoration" name="test_torch_random_state_restoration" time="3.139" /><testcase classname="integration.test_comprehensive_serialization.TestHistoryPreservation" name="test_history_preservation" time="1.769" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemBasic" name="test_2_spiral_learning" time="712.241"><failure message="AssertionError: Network did not learn: initial_loss=0.243668, final_loss=0.243668: improvement=0.000000 &lt; min_improvement=0.01">self = &lt;test_spiral_problem.TestSpiralProblemBasic object at 0x7cecd1e67110&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecd1a578c0&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    def test_2_spiral_learning(self, spiral_network):
        """Test that network can learn 2-spiral problem."""
        set_deterministic_behavior(42)
    
        # Generate 2-spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=50,
            noise=0.05,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history, elapsed_time = measure_training_time(
            spiral_network, x, y, max_epochs=10, early_stopping=False
        )
        final_accuracy = spiral_network.calculate_accuracy(x, y)
        # Verify learning occurred
&gt;       assert_network_learns(
            initial_loss=history['train_loss'][0],
            final_loss=history['train_loss'][-1],
            min_improvement=0.01
        )

src/tests/integration/test_spiral_problem.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

initial_loss = 0.2436680942773819, final_loss = 0.2436680942773819, min_improvement = 0.01, msg = 'Network did not learn: initial_loss=0.243668, final_loss=0.243668'

    def assert_network_learns(
        initial_loss: float,
        final_loss: float,
        min_improvement: float = 0.01,
        msg: Optional[str] = None
    ) -&gt; None:
        """
        Assert that network shows learning (loss improvement).
    
        Args:
            initial_loss: Loss at start of training
            final_loss: Loss at end of training
            min_improvement: Minimum relative improvement required
            msg: Optional error message
        """
        if msg is None:
            msg = f"Network did not learn: initial_loss={initial_loss:.6f}, final_loss={final_loss:.6f}"
    
        improvement = (initial_loss - final_loss) / initial_loss
&gt;       assert improvement &gt;= min_improvement, f"{msg}: improvement={improvement:.6f} &lt; min_improvement={min_improvement}" # trunk-ignore(bandit/B101)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: Network did not learn: initial_loss=0.243668, final_loss=0.243668: improvement=0.000000 &lt; min_improvement=0.01

src/tests/helpers/assertions.py:340: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemBasic" name="test_3_spiral_learning" time="820.323"><failure message="assert 0.35 &gt; 0.35">self = &lt;test_spiral_problem.TestSpiralProblemBasic object at 0x7cecd1e674d0&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc5d1b0e0&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    def test_3_spiral_learning(self, spiral_network):
        """Test that network can learn 3-spiral problem."""
        set_deterministic_behavior(42)
    
        # Generate 3-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=3,
            n_per_spiral=40,
            noise=0.03,
            seed=42
        )
    
        # Adjust network for 3-class problem
        spiral_network.output_size = 3
        spiral_network.output_weights = torch.randn(
            spiral_network.input_size, 3, requires_grad=True
        ) * spiral_network.random_value_scale
        spiral_network.output_bias = torch.randn(3, requires_grad=True) * spiral_network.random_value_scale
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=8)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Verify learning
&gt;       assert final_accuracy &gt; initial_accuracy  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.35 &gt; 0.35

src/tests/integration/test_spiral_problem.py:100: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemProgressive" name="test_n_spiral_difficulty_progression[2]" time="558.994"><failure message="assert 0.5 &gt;= 0.5166666666666667">self = &lt;test_spiral_problem.TestSpiralProblemProgressive object at 0x7cecd1e67890&gt;, n_spirals = 2

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    @pytest.mark.parametrize("n_spirals", [2, 3, 4])
    def test_n_spiral_difficulty_progression(self, n_spirals):
        """Test that network can handle increasing spiral complexity."""
        set_deterministic_behavior(42)
    
        # Create network configured for n-spiral problem
        from cascade_correlation.cascade_correlation import CascadeCorrelationNetwork
        network = CascadeCorrelationNetwork.create_simple_network(
            input_size=2,
            output_size=n_spirals,
            learning_rate=0.05,
            max_hidden_units=min(8, n_spirals * 2),
            candidate_pool_size=12,
            correlation_threshold=0.15
        )
    
        # Generate n-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=n_spirals,
            n_per_spiral=30,
            noise=0.02,
            seed=42
        )
    
        # Train network
        initial_accuracy = network.calculate_accuracy(x, y)
        history = network.fit(x, y, max_epochs=6)
        final_accuracy = network.calculate_accuracy(x, y)
    
        # Basic learning verification
&gt;       assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.5 &gt;= 0.5166666666666667

src/tests/integration/test_spiral_problem.py:147: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemProgressive" name="test_n_spiral_difficulty_progression[3]" time="851.679"><failure message="assert 0.37777777777777777 &gt; (0.3333333333333333 * 1.2)">self = &lt;test_spiral_problem.TestSpiralProblemProgressive object at 0x7cecd1e679d0&gt;, n_spirals = 3

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    @pytest.mark.parametrize("n_spirals", [2, 3, 4])
    def test_n_spiral_difficulty_progression(self, n_spirals):
        """Test that network can handle increasing spiral complexity."""
        set_deterministic_behavior(42)
    
        # Create network configured for n-spiral problem
        from cascade_correlation.cascade_correlation import CascadeCorrelationNetwork
        network = CascadeCorrelationNetwork.create_simple_network(
            input_size=2,
            output_size=n_spirals,
            learning_rate=0.05,
            max_hidden_units=min(8, n_spirals * 2),
            candidate_pool_size=12,
            correlation_threshold=0.15
        )
    
        # Generate n-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=n_spirals,
            n_per_spiral=30,
            noise=0.02,
            seed=42
        )
    
        # Train network
        initial_accuracy = network.calculate_accuracy(x, y)
        history = network.fit(x, y, max_epochs=6)
        final_accuracy = network.calculate_accuracy(x, y)
    
        # Basic learning verification
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Expected accuracy should decrease with complexity but still be above random
        random_accuracy = 1.0 / n_spirals
        # At least 20% better than random
&gt;       assert final_accuracy &gt; random_accuracy * 1.2  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.37777777777777777 &gt; (0.3333333333333333 * 1.2)

src/tests/integration/test_spiral_problem.py:152: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemProgressive" name="test_n_spiral_difficulty_progression[4]" time="964.073"><failure message="assert 0.26666666666666666 &gt; (0.25 * 1.2)">self = &lt;test_spiral_problem.TestSpiralProblemProgressive object at 0x7cecd1e55810&gt;, n_spirals = 4

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.slow
    @pytest.mark.parametrize("n_spirals", [2, 3, 4])
    def test_n_spiral_difficulty_progression(self, n_spirals):
        """Test that network can handle increasing spiral complexity."""
        set_deterministic_behavior(42)
    
        # Create network configured for n-spiral problem
        from cascade_correlation.cascade_correlation import CascadeCorrelationNetwork
        network = CascadeCorrelationNetwork.create_simple_network(
            input_size=2,
            output_size=n_spirals,
            learning_rate=0.05,
            max_hidden_units=min(8, n_spirals * 2),
            candidate_pool_size=12,
            correlation_threshold=0.15
        )
    
        # Generate n-spiral data
        # x, y, info = SpiralDataGenerator.generate_n_spiral(
        x, y, _ = SpiralDataGenerator.generate_n_spiral(
            n_spirals=n_spirals,
            n_per_spiral=30,
            noise=0.02,
            seed=42
        )
    
        # Train network
        initial_accuracy = network.calculate_accuracy(x, y)
        history = network.fit(x, y, max_epochs=6)
        final_accuracy = network.calculate_accuracy(x, y)
    
        # Basic learning verification
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Expected accuracy should decrease with complexity but still be above random
        random_accuracy = 1.0 / n_spirals
        # At least 20% better than random
&gt;       assert final_accuracy &gt; random_accuracy * 1.2  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.26666666666666666 &gt; (0.25 * 1.2)

src/tests/integration/test_spiral_problem.py:152: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_noise_robustness[0.01]" time="780.250"><failure message="assert 0.525 &gt; 0.55">self = &lt;test_spiral_problem.TestSpiralProblemRobustness object at 0x7cecd1e67390&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc5d1ba10&gt;, noise_level = 0.01

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.parametrize("noise_level", [0.01, 0.05, 0.1])
    def test_spiral_noise_robustness(self, spiral_network, noise_level):
        """Test network performance with different noise levels."""
        set_deterministic_behavior(42)
    
        # Generate noisy spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=40,
            noise=noise_level,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=6)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should learn even with noise, though performance may degrade
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Performance should still be better than random (0.5 for 2-class)
        if noise_level &lt;= 0.05:  # sourcery skip: no-conditionals-in-tests
            # Should handle small noise well
&gt;           assert final_accuracy &gt; 0.55  # trunk-ignore(bandit/B101)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           assert 0.525 &gt; 0.55

src/tests/integration/test_spiral_problem.py:188: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_noise_robustness[0.05]" time="657.431"><failure message="assert 0.55 &gt; 0.55">self = &lt;test_spiral_problem.TestSpiralProblemRobustness object at 0x7cecd1e67b10&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc5d1be00&gt;, noise_level = 0.05

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.parametrize("noise_level", [0.01, 0.05, 0.1])
    def test_spiral_noise_robustness(self, spiral_network, noise_level):
        """Test network performance with different noise levels."""
        set_deterministic_behavior(42)
    
        # Generate noisy spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=40,
            noise=noise_level,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=6)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should learn even with noise, though performance may degrade
        assert final_accuracy &gt;= initial_accuracy # trunk-ignore(bandit/B101)
    
        # Performance should still be better than random (0.5 for 2-class)
        if noise_level &lt;= 0.05:  # sourcery skip: no-conditionals-in-tests
            # Should handle small noise well
&gt;           assert final_accuracy &gt; 0.55  # trunk-ignore(bandit/B101)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           assert 0.55 &gt; 0.55

src/tests/integration/test_spiral_problem.py:188: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_noise_robustness[0.1]" time="1149.649" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_data_size_scaling[20]" time="582.706"><failure message="assert 0.5 &gt; 0.525">self = &lt;test_spiral_problem.TestSpiralProblemRobustness object at 0x7cecd1e55ba0&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc52b41a0&gt;, n_per_spiral = 20

    @pytest.mark.integration
    @pytest.mark.spiral
    @pytest.mark.parametrize("n_per_spiral", [20, 50, 100])
    def test_spiral_data_size_scaling(self, spiral_network, n_per_spiral):
        """Test network performance with different dataset sizes."""
        set_deterministic_behavior(42)
    
        # Generate spiral data of different sizes
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=n_per_spiral,
            noise=0.03,
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=5)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should learn regardless of data size
&gt;       assert final_accuracy &gt; initial_accuracy # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.5 &gt; 0.525

src/tests/integration/test_spiral_problem.py:216: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_data_size_scaling[50]" time="570.641" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemRobustness" name="test_spiral_data_size_scaling[100]" time="556.806" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemVisualization" name="test_spiral_training_progression" time="608.915"><failure message="assert 0.5 &gt; 0.5">self = &lt;test_spiral_problem.TestSpiralProblemVisualization object at 0x7cecd1e67ed0&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc52b4440&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    def test_spiral_training_progression(self, spiral_network):
        """Test and analyze training progression on spiral problem."""
        set_deterministic_behavior(42)
    
        # Generate spiral data
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=60,
            noise=0.04,
            seed=42
        )
    
        # Split into train/validation
        n_train = int(0.8 * len(x))
        indices = torch.randperm(len(x))
        train_indices, val_indices = indices[:n_train], indices[n_train:]
    
        x_train, y_train = x[train_indices], y[train_indices]
        x_val, y_val = x[val_indices], y[val_indices]
    
        # Train with validation
        history = spiral_network.fit(
            x_train, y_train,
            x_val, y_val,
            max_epochs=8,
            early_stopping=True
        )
    
        # Analyze training progression
        assert len(history['train_loss']) &gt; 0 # trunk-ignore(bandit/B101)
        assert len(history['train_accuracy']) &gt; 0 # trunk-ignore(bandit/B101)
    
        if 'value_loss' in history and history['value_loss']:  # sourcery skip: no-conditionals-in-tests
            assert len(history['value_loss']) &gt; 0 # trunk-ignore(bandit/B101)
            assert len(history['value_accuracy']) &gt; 0 # trunk-ignore(bandit/B101)
    
            # Validation accuracy should be reasonable
            final_val_accuracy = history['value_accuracy'][-1]
&gt;           assert final_val_accuracy &gt; 0.5 # trunk-ignore(bandit/B101)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           assert 0.5 &gt; 0.5

src/tests/integration/test_spiral_problem.py:268: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemEdgeCases" name="test_minimal_spiral_data" time="340.760" /><testcase classname="integration.test_spiral_problem.TestSpiralProblemEdgeCases" name="test_perfect_spiral_separation" time="641.067"><failure message="assert 0.5166666666666667 &gt; 0.5166666666666667">self = &lt;test_spiral_problem.TestSpiralProblemEdgeCases object at 0x7cecd19902d0&gt;, spiral_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc52b42f0&gt;

    @pytest.mark.integration
    @pytest.mark.spiral
    def test_perfect_spiral_separation(self, spiral_network):
        """Test network with perfectly separated spiral data."""
        set_deterministic_behavior(42)
    
        # Generate data with no noise (perfect separation)
        # x, y, info = SpiralDataGenerator.generate_2_spiral(
        x, y, _ = SpiralDataGenerator.generate_2_spiral(
            n_per_spiral=30,
            noise=0.0,  # No noise - perfect separation
            seed=42
        )
    
        # Train network
        initial_accuracy = spiral_network.calculate_accuracy(x, y)
        history = spiral_network.fit(x, y, max_epochs=8)
        final_accuracy = spiral_network.calculate_accuracy(x, y)
    
        # Should achieve very high accuracy with perfect data
&gt;       assert final_accuracy &gt; initial_accuracy  # trunk-ignore(bandit/B101)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 0.5166666666666667 &gt; 0.5166666666666667

src/tests/integration/test_spiral_problem.py:332: AssertionError</failure></testcase><testcase classname="integration.test_spiral_problem.TestSpiralProblemComparison" name="test_spiral_configuration_comparison" time="1924.045" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_perfect_accuracy" time="0.941" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_zero_accuracy" time="0.759" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_random_accuracy" time="0.826" /><testcase classname="unit.test_accuracy.TestAccuracyCalculation" name="test_accuracy_with_trained_network" time="79.892" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[1]" time="0.855" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[5]" time="0.848" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[10]" time="0.882" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[50]" time="0.980" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_batch_sizes[100]" time="0.880" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[2]" time="0.769" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[3]" time="0.741" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[5]" time="0.733" /><testcase classname="unit.test_accuracy.TestAccuracyShapes" name="test_accuracy_output_sizes[10]" time="0.769" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_none_inputs" time="0.860" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_mismatched_batch_sizes" time="0.860" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_wrong_shapes" time="0.889" /><testcase classname="unit.test_accuracy.TestAccuracyValidation" name="test_accuracy_non_tensor_inputs" time="0.797" /><testcase classname="unit.test_accuracy.TestAccuracyArgmax" name="test_accuracy_argmax_behavior" time="0.783" /><testcase classname="unit.test_accuracy.TestAccuracyArgmax" name="test_accuracy_tie_breaking" time="0.690" /><testcase classname="unit.test_accuracy.TestAccuracyEdgeCases" name="test_accuracy_empty_batch" time="0.709" /><testcase classname="unit.test_accuracy.TestAccuracyEdgeCases" name="test_accuracy_single_sample" time="0.736" /><testcase classname="unit.test_accuracy.TestAccuracyEdgeCases" name="test_accuracy_extreme_predictions" time="0.765" /><testcase classname="unit.test_accuracy.TestAccuracyConsistency" name="test_accuracy_methods_consistency" time="0.701" /><testcase classname="unit.test_accuracy.TestAccuracyConsistency" name="test_accuracy_deterministic" time="0.753" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_multiclass_accuracy[3]" time="0.664" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_multiclass_accuracy[5]" time="0.596" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_multiclass_accuracy[10]" time="0.639" /><testcase classname="unit.test_accuracy.TestAccuracyMulticlass" name="test_imbalanced_accuracy" time="0.760" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_inheritance[happy-path-candidate-training-manager]" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_inheritance[base-manager-direct]" time="0.002" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args0-register_kwargs0-None-register-method-happy-path]" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args1-register_kwargs1-None-register-method-with-callable]" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args2-register_kwargs2-TypeError-register-method-none-name]" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_register[register_args3-register_kwargs3-TypeError-register-method-missing-args]" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[fork-None-start-method-fork]" time="0.002"><skipped type="pytest.skip" message="Skipping actual start() call for 'fork' to avoid multiprocessing complexity">/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/unit/test_candidate_training_manager.py:98: Skipping actual start() call for 'fork' to avoid multiprocessing complexity</skipped></testcase><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[spawn-None-start-method-spawn]" time="0.001"><skipped type="pytest.skip" message="Skipping actual start() call for 'spawn' to avoid multiprocessing complexity">/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/unit/test_candidate_training_manager.py:98: Skipping actual start() call for 'spawn' to avoid multiprocessing complexity</skipped></testcase><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[forkserver-None-start-method-forkserver]" time="0.001"><skipped type="pytest.skip" message="Skipping actual start() call for 'forkserver' to avoid multiprocessing complexity">/home/pcalnon/Development/python/Juniper/JuniperCascor/juniper_cascor/src/tests/unit/test_candidate_training_manager.py:98: Skipping actual start() call for 'forkserver' to avoid multiprocessing complexity</skipped></testcase><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_start_method[invalid_method-ValueError-start-method-invalid]" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_repr_and_str" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_address_property" time="0.001" /><testcase classname="unit.test_candidate_training_manager" name="test_candidate_training_manager_shutdown_without_start" time="0.002" /><testcase classname="unit.test_cascor_fix" name="test_sequential_candidate_training" time="12.577" /><testcase classname="unit.test_cascor_fix" name="test_individual_candidates" time="11.740" /><testcase classname="unit.test_critical_fixes" name="test_1_dataclass_fields" time="0.002" /><testcase classname="unit.test_critical_fixes" name="test_2_network_creation" time="0.701" /><testcase classname="unit.test_critical_fixes" name="test_3_candidate_training" time="5.626" /><testcase classname="unit.test_critical_fixes" name="test_4_get_single_candidate_data" time="0.655" /><testcase classname="unit.test_critical_fixes" name="test_5_training_results_dataclass" time="0.002" /><testcase classname="unit.test_final" name="test_candidate_units_simple" time="17.855" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_no_hidden_units" time="2.284" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_single_hidden_unit" time="0.780" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_multiple_hidden_units" time="0.737" /><testcase classname="unit.test_forward_pass.TestForwardPassBasics" name="test_forward_pass_deterministic" time="0.737" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[1]" time="0.768" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[5]" time="0.812" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[10]" time="1.000" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_batch_sizes[50]" time="0.975" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[1]" time="0.890" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[2]" time="0.776" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[5]" time="0.767" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_input_sizes[10]" time="0.627" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[1]" time="0.742" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[2]" time="0.681" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[5]" time="0.696" /><testcase classname="unit.test_forward_pass.TestForwardPassShapes" name="test_forward_pass_output_sizes[10]" time="0.767" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_invalid_input_shape" time="0.834" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_1d_input" time="0.901" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_empty_input" time="0.868" /><testcase classname="unit.test_forward_pass.TestForwardPassValidation" name="test_forward_pass_nan_input" time="0.848"><failure message="cascade_correlation.cascade_correlation_exceptions.cascade_correlation_exceptions.ValidationError: Parameter 'x' contains NaN values">self = &lt;test_forward_pass.TestForwardPassValidation object at 0x7cecd1974640&gt;, simple_network = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc52b46e0&gt;

    @pytest.mark.unit
    def test_forward_pass_nan_input(self, simple_network):
        """Test forward pass with NaN input raises ValidationError.
    
        The network validates inputs and rejects NaN values to prevent
        silent propagation of invalid data through the network.
        """
        from cascade_correlation_exceptions.cascade_correlation_exceptions import ValidationError
    
        nan_input = torch.full((5, simple_network.input_size), float('nan'))
    
        # Network should reject NaN inputs with a ValidationError
        with pytest.raises(ValidationError, match="contains NaN values"):
&gt;           simple_network.forward(nan_input)

src/tests/unit/test_forward_pass.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc52b46e0&gt;, x = tensor([[nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan]])

    def forward(self, x: torch.Tensor = None) -&gt; torch.Tensor:
        """
        Perform a forward pass through the network.
        Args:
            x: Input tensor (batch_size, input_features)
        Raises:
            ValidationError: If input tensor is invalid or has wrong shape
        Returns:
            Network output tensor (batch_size, output_features)
        """
        # Validate input (allow empty tensors for edge case handling)
&gt;       self._validate_tensor_input(x, "x", allow_empty=True)

src/cascade_correlation/cascade_correlation.py:1357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;cascade_correlation.cascade_correlation.CascadeCorrelationNetwork object at 0x7cecc52b46e0&gt;, x = tensor([[nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan],
        [nan, nan]]), param_name = 'x', allow_none = False
allow_empty = True

    def _validate_tensor_input(
        self,
        x: torch.Tensor,
        param_name: str = "x",
        allow_none: bool = False,
        allow_empty: bool = False,
    ) -&gt; None:
        """
        Validate tensor input parameters.
        Args:
            x: Input tensor to validate
            param_name: Name of the parameter for error messages
            allow_none: Whether to allow None values
            allow_empty: Whether to allow empty (zero-batch) tensors
        Raises:
            ValidationError: If tensor is invalid
        """
        if allow_none and x is None:
            return
        if x is None:
            raise ValidationError(f"Parameter '{param_name}' cannot be None")
        if not isinstance(x, torch.Tensor):
            raise ValidationError(
                f"Parameter '{param_name}' must be a torch.Tensor, got {type(x)}"
            )
        if x.numel() == 0 and not allow_empty:
            raise ValidationError(f"Parameter '{param_name}' cannot be an empty tensor")
        # Skip NaN/Inf checks for empty tensors
        if x.numel() &gt; 0:
            if torch.isnan(x).any():
&gt;               raise ValidationError(f"Parameter '{param_name}' contains NaN values")
E               cascade_correlation.cascade_correlation_exceptions.cascade_correlation_exceptions.ValidationError: Parameter 'x' contains NaN values

src/cascade_correlation/cascade_correlation.py:976: ValidationError</failure></testcase><testcase classname="unit.test_forward_pass.TestForwardPassCascading" name="test_cascading_connections" time="0.929" /><testcase classname="unit.test_forward_pass.TestForwardPassCascading" name="test_hidden_unit_output_shapes" time="0.844" /><testcase classname="unit.test_forward_pass.TestForwardPassGradients" name="test_forward_pass_gradients_enabled" time="0.790" /><testcase classname="unit.test_forward_pass.TestForwardPassGradients" name="test_forward_pass_no_grad" time="0.776" /><testcase classname="unit.test_forward_pass.TestForwardPassActivationFunctions" name="test_forward_pass_different_activations[tanh]" time="0.752" /><testcase classname="unit.test_forward_pass.TestForwardPassActivationFunctions" name="test_forward_pass_different_activations[sigmoid]" time="0.725" /><testcase classname="unit.test_forward_pass.TestForwardPassActivationFunctions" name="test_forward_pass_different_activations[relu]" time="0.761" /><testcase classname="unit.test_forward_pass.TestForwardPassEdgeCases" name="test_forward_pass_single_sample" time="0.735" /><testcase classname="unit.test_forward_pass.TestForwardPassEdgeCases" name="test_forward_pass_large_batch" time="0.812" /><testcase classname="unit.test_forward_pass.TestForwardPassEdgeCases" name="test_forward_pass_extreme_weights" time="0.732" /><testcase classname="unit.test_p1_fixes" name="test_1_early_stopping" time="3.966" /><testcase classname="unit.test_p1_fixes" name="test_2_optimizer_serialization" time="1.509" /><testcase classname="unit.test_p1_fixes" name="test_3_training_counters_persistence" time="1.464" /><testcase classname="unit.test_p1_fixes" name="test_4_queue_timeout" time="0.002" /><testcase classname="unit.test_p1_fixes" name="test_5_optimizer_initialization" time="0.679" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_perfect_prediction" time="0.801" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_computation" time="0.794" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_symmetric" time="0.746" /><testcase classname="unit.test_residual_error.TestResidualErrorBasics" name="test_residual_error_no_grad" time="0.783" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[1]" time="0.824" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[5]" time="0.774" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[10]" time="0.770" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_batch_sizes[50]" time="0.731" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[1]" time="0.607" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[2]" time="0.612" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[5]" time="0.683" /><testcase classname="unit.test_residual_error.TestResidualErrorShapes" name="test_residual_error_output_sizes[10]" time="0.670" /><testcase classname="unit.test_residual_error.TestResidualErrorMagnitude" name="test_residual_error_magnitude_untrained" time="0.800" /><testcase classname="unit.test_residual_error.TestResidualErrorMagnitude" name="test_residual_error_zero_targets" time="0.707" /><testcase classname="unit.test_residual_error.TestResidualErrorMagnitude" name="test_residual_error_distribution" time="0.771" /><testcase classname="unit.test_residual_error.TestResidualErrorValidation" name="test_residual_error_mismatched_shapes" time="0.773" /><testcase classname="unit.test_residual_error.TestResidualErrorValidation" name="test_residual_error_wrong_target_size" time="0.733" /><testcase classname="unit.test_residual_error.TestResidualErrorValidation" name="test_residual_error_empty_input" time="0.767" /><testcase classname="unit.test_residual_error.TestResidualErrorNumericalStability" name="test_residual_error_extreme_values" time="0.820" /><testcase classname="unit.test_residual_error.TestResidualErrorNumericalStability" name="test_residual_error_inf_nan_handling" time="0.760" /><testcase classname="unit.test_residual_error.TestResidualErrorWithHiddenUnits" name="test_residual_error_with_hidden_units" time="0.775" /><testcase classname="unit.test_residual_error.TestResidualErrorWithHiddenUnits" name="test_residual_error_changes_with_training" time="0.839" /><testcase classname="unit.test_residual_error.TestResidualErrorCorrelation" name="test_residual_error_for_correlation" time="0.778" /><testcase classname="unit.test_residual_error.TestResidualErrorCorrelation" name="test_residual_error_mean_centering" time="0.745" /></testsuite></testsuites>